# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: records.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from gpx_data import models


DELETE_RECORD_BY_ID = """-- name: delete_record_by_id \\:exec
DELETE FROM Records WHERE Id = :p1
"""


DELETE_RECORDS_BY_USER_ID = """-- name: delete_records_by_user_id \\:exec
DELETE FROM Records WHERE UserId = :p1
"""


FLAG_RECORD = """-- name: flag_record \\:one
UPDATE Records SET FlagReason = :p2 WHERE Id = :p1 RETURNING id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata
"""


GET_RECORDS = """-- name: get_records \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata FROM Records
"""


GET_RECORDS_BY_FILE_ID = """-- name: get_records_by_file_id \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata FROM Records WHERE FileId = :p1 LIMIT 1
"""


GET_RECORDS_BY_TRAIL_NAME = """-- name: get_records_by_trail_name \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata FROM Records WHERE TrailName = :p1
"""


GET_RECORDS_BY_USER_ID = """-- name: get_records_by_user_id \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata FROM Records WHERE UserId = :p1
"""


INSERT_RECORD = """-- name: insert_record \\:one
INSERT INTO Records (
    Id, UserId, FileId, TrailName, RecordedAt, Duration, Distance, Ascent, Descent, TrailData
) VALUES (
    :p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9, :p10
) RETURNING id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata
"""


@dataclasses.dataclass()
class InsertRecordParams:
    id: uuid.UUID
    userid: str
    fileid: uuid.UUID
    trailname: str
    recordedat: Optional[datetime.datetime]
    duration: Optional[float]
    distance: Optional[float]
    ascent: Optional[float]
    descent: Optional[float]
    traildata: Any


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def delete_record_by_id(self, *, id: uuid.UUID) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_RECORD_BY_ID), {"p1": id})

    def delete_records_by_user_id(self, *, userid: str) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_RECORDS_BY_USER_ID), {"p1": userid})

    def flag_record(self, *, id: uuid.UUID, flagreason: Optional[str]) -> Optional[models.Record]:
        row = self._conn.execute(sqlalchemy.text(FLAG_RECORD), {"p1": id, "p2": flagreason}).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
            flagreason=row[9],
            traildata=row[10],
        )

    def get_records(self) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORDS))
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    def get_records_by_file_id(self, *, fileid: uuid.UUID) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORDS_BY_FILE_ID), {"p1": fileid})
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    def get_records_by_trail_name(self, *, trailname: str) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORDS_BY_TRAIL_NAME), {"p1": trailname})
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    def get_records_by_user_id(self, *, userid: str) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORDS_BY_USER_ID), {"p1": userid})
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    def insert_record(self, arg: InsertRecordParams) -> Optional[models.Record]:
        row = self._conn.execute(sqlalchemy.text(INSERT_RECORD), {
            "p1": arg.id,
            "p2": arg.userid,
            "p3": arg.fileid,
            "p4": arg.trailname,
            "p5": arg.recordedat,
            "p6": arg.duration,
            "p7": arg.distance,
            "p8": arg.ascent,
            "p9": arg.descent,
            "p10": arg.traildata,
        }).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
            flagreason=row[9],
            traildata=row[10],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def delete_record_by_id(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_RECORD_BY_ID), {"p1": id})

    async def delete_records_by_user_id(self, *, userid: str) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_RECORDS_BY_USER_ID), {"p1": userid})

    async def flag_record(self, *, id: uuid.UUID, flagreason: Optional[str]) -> Optional[models.Record]:
        row = (await self._conn.execute(sqlalchemy.text(FLAG_RECORD), {"p1": id, "p2": flagreason})).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
            flagreason=row[9],
            traildata=row[10],
        )

    async def get_records(self) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORDS))
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    async def get_records_by_file_id(self, *, fileid: uuid.UUID) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORDS_BY_FILE_ID), {"p1": fileid})
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    async def get_records_by_trail_name(self, *, trailname: str) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORDS_BY_TRAIL_NAME), {"p1": trailname})
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    async def get_records_by_user_id(self, *, userid: str) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORDS_BY_USER_ID), {"p1": userid})
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
                flagreason=row[9],
                traildata=row[10],
            )

    async def insert_record(self, arg: InsertRecordParams) -> Optional[models.Record]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_RECORD), {
            "p1": arg.id,
            "p2": arg.userid,
            "p3": arg.fileid,
            "p4": arg.trailname,
            "p5": arg.recordedat,
            "p6": arg.duration,
            "p7": arg.distance,
            "p8": arg.ascent,
            "p9": arg.descent,
            "p10": arg.traildata,
        })).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
            flagreason=row[9],
            traildata=row[10],
        )
