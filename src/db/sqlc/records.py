# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: records.sql
import dataclasses
import datetime
from typing import AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from gpx_data import models


DELETE_RECORD = """-- name: delete_record \\:exec
DELETE FROM Records WHERE Id = :p1
"""


GET_RECORD_BY_DISTANCE = """-- name: get_record_by_distance \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent FROM Records WHERE Distance = :p1
"""


GET_RECORD_BY_DURATION = """-- name: get_record_by_duration \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent FROM Records WHERE Duration = :p1
"""


GET_RECORD_BY_ID = """-- name: get_record_by_id \\:one
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent FROM Records WHERE Id = :p1 LIMIT 1
"""


GET_RECORDS = """-- name: get_records \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent FROM Records
"""


GET_RECORDS_BY_FILE_ID = """-- name: get_records_by_file_id \\:one
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent FROM Records WHERE FileId = :p1 LIMIT 1
"""


GET_RECORDS_BY_USER_ID = """-- name: get_records_by_user_id \\:many
SELECT id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent FROM Records WHERE UserId = :p1
"""


INSERT_RECORD = """-- name: insert_record \\:one
INSERT INTO Records (
    Id, UserId, FileId, TrailName, RecordedAt, Duration, Distance, Ascent, Descent
) VALUES (
    :p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9
) RETURNING id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent
"""


@dataclasses.dataclass()
class InsertRecordParams:
    id: uuid.UUID
    userid: str
    fileid: uuid.UUID
    trailname: str
    recordedat: Optional[datetime.datetime]
    duration: Optional[float]
    distance: Optional[float]
    ascent: Optional[float]
    descent: Optional[float]


REMOVE_ALL_RECORDS = """-- name: remove_all_records \\:exec
DELETE FROM Records
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def delete_record(self, *, id: uuid.UUID) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_RECORD), {"p1": id})

    def get_record_by_distance(self, *, distance: Optional[float]) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORD_BY_DISTANCE), {"p1": distance})
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    def get_record_by_duration(self, *, duration: Optional[float]) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORD_BY_DURATION), {"p1": duration})
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    def get_record_by_id(self, *, id: uuid.UUID) -> Optional[models.Record]:
        row = self._conn.execute(sqlalchemy.text(GET_RECORD_BY_ID), {"p1": id}).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
        )

    def get_records(self) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORDS))
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    def get_records_by_file_id(self, *, fileid: uuid.UUID) -> Optional[models.Record]:
        row = self._conn.execute(sqlalchemy.text(GET_RECORDS_BY_FILE_ID), {"p1": fileid}).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
        )

    def get_records_by_user_id(self, *, userid: str) -> Iterator[models.Record]:
        result = self._conn.execute(sqlalchemy.text(GET_RECORDS_BY_USER_ID), {"p1": userid})
        for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    def insert_record(self, arg: InsertRecordParams) -> Optional[models.Record]:
        row = self._conn.execute(sqlalchemy.text(INSERT_RECORD), {
            "p1": arg.id,
            "p2": arg.userid,
            "p3": arg.fileid,
            "p4": arg.trailname,
            "p5": arg.recordedat,
            "p6": arg.duration,
            "p7": arg.distance,
            "p8": arg.ascent,
            "p9": arg.descent,
        }).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
        )

    def remove_all_records(self) -> None:
        self._conn.execute(sqlalchemy.text(REMOVE_ALL_RECORDS))


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def delete_record(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_RECORD), {"p1": id})

    async def get_record_by_distance(self, *, distance: Optional[float]) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORD_BY_DISTANCE), {"p1": distance})
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    async def get_record_by_duration(self, *, duration: Optional[float]) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORD_BY_DURATION), {"p1": duration})
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    async def get_record_by_id(self, *, id: uuid.UUID) -> Optional[models.Record]:
        row = (await self._conn.execute(sqlalchemy.text(GET_RECORD_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
        )

    async def get_records(self) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORDS))
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    async def get_records_by_file_id(self, *, fileid: uuid.UUID) -> Optional[models.Record]:
        row = (await self._conn.execute(sqlalchemy.text(GET_RECORDS_BY_FILE_ID), {"p1": fileid})).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
        )

    async def get_records_by_user_id(self, *, userid: str) -> AsyncIterator[models.Record]:
        result = await self._conn.stream(sqlalchemy.text(GET_RECORDS_BY_USER_ID), {"p1": userid})
        async for row in result:
            yield models.Record(
                id=row[0],
                userid=row[1],
                fileid=row[2],
                trailname=row[3],
                recordedat=row[4],
                duration=row[5],
                distance=row[6],
                ascent=row[7],
                descent=row[8],
            )

    async def insert_record(self, arg: InsertRecordParams) -> Optional[models.Record]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_RECORD), {
            "p1": arg.id,
            "p2": arg.userid,
            "p3": arg.fileid,
            "p4": arg.trailname,
            "p5": arg.recordedat,
            "p6": arg.duration,
            "p7": arg.distance,
            "p8": arg.ascent,
            "p9": arg.descent,
        })).first()
        if row is None:
            return None
        return models.Record(
            id=row[0],
            userid=row[1],
            fileid=row[2],
            trailname=row[3],
            recordedat=row[4],
            duration=row[5],
            distance=row[6],
            ascent=row[7],
            descent=row[8],
        )

    async def remove_all_records(self) -> None:
        await self._conn.execute(sqlalchemy.text(REMOVE_ALL_RECORDS))
