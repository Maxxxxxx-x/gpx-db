# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.27.0
# source: gpx_files.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from gpx_data import models


DELETE_GPX_FILE_BY_ID = """-- name: delete_gpx_file_by_id \\:exec
DELETE FROM GpxFiles WHERE Id = :p1
"""


DELETE_GPX_FILES = """-- name: delete_gpx_files \\:exec
DELETE FROM GpxFiles
"""


GET_GPX_FILES = """-- name: get_gpx_files \\:many
SELECT id, filepath, checksum FROM GpxFiles
"""


GET_GPX_FILES_BY_ID = """-- name: get_gpx_files_by_id \\:many
SELECT id, filepath, checksum FROM GpxFiles WHERE Id = :p1 LIMIT 1
"""


GET_GPX_FILES_BY_USER_ID = """-- name: get_gpx_files_by_user_id \\:many
SELECT gpxfiles.id, filepath, checksum, records.id, userid, fileid, trailname, recordedat, duration, distance, ascent, descent, flagreason, traildata FROM GpxFiles
INNER JOIN Records ON GpxFiles.Id = Records.FileId AND Records.UserId = :p1
"""


@dataclasses.dataclass()
class GetGpxFilesByUserIdRow:
    id: str
    filepath: str
    checksum: str
    id_2: uuid.UUID
    userid: str
    fileid: uuid.UUID
    trailname: str
    recordedat: Optional[datetime.datetime]
    duration: Optional[float]
    distance: Optional[float]
    ascent: Optional[float]
    descent: Optional[float]
    flagreason: Optional[str]
    traildata: Any


INSERT_GPX_FILE = """-- name: insert_gpx_file \\:one
INSERT INTO GpxFiles (
    Id, FilePath, Checksum
) VALUES (
    :p1, :p2, :p3
) RETURNING id, filepath, checksum
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def delete_gpx_file_by_id(self, *, id: str) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_GPX_FILE_BY_ID), {"p1": id})

    def delete_gpx_files(self) -> None:
        self._conn.execute(sqlalchemy.text(DELETE_GPX_FILES))

    def get_gpx_files(self) -> Iterator[models.Gpxfile]:
        result = self._conn.execute(sqlalchemy.text(GET_GPX_FILES))
        for row in result:
            yield models.Gpxfile(
                id=row[0],
                filepath=row[1],
                checksum=row[2],
            )

    def get_gpx_files_by_id(self, *, id: str) -> Iterator[models.Gpxfile]:
        result = self._conn.execute(sqlalchemy.text(GET_GPX_FILES_BY_ID), {"p1": id})
        for row in result:
            yield models.Gpxfile(
                id=row[0],
                filepath=row[1],
                checksum=row[2],
            )

    def get_gpx_files_by_user_id(self, *, userid: str) -> Iterator[GetGpxFilesByUserIdRow]:
        result = self._conn.execute(sqlalchemy.text(GET_GPX_FILES_BY_USER_ID), {"p1": userid})
        for row in result:
            yield GetGpxFilesByUserIdRow(
                id=row[0],
                filepath=row[1],
                checksum=row[2],
                id_2=row[3],
                userid=row[4],
                fileid=row[5],
                trailname=row[6],
                recordedat=row[7],
                duration=row[8],
                distance=row[9],
                ascent=row[10],
                descent=row[11],
                flagreason=row[12],
                traildata=row[13],
            )

    def insert_gpx_file(self, *, id: str, filepath: str, checksum: str) -> Optional[models.Gpxfile]:
        row = self._conn.execute(sqlalchemy.text(INSERT_GPX_FILE), {"p1": id, "p2": filepath, "p3": checksum}).first()
        if row is None:
            return None
        return models.Gpxfile(
            id=row[0],
            filepath=row[1],
            checksum=row[2],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def delete_gpx_file_by_id(self, *, id: str) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_GPX_FILE_BY_ID), {"p1": id})

    async def delete_gpx_files(self) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_GPX_FILES))

    async def get_gpx_files(self) -> AsyncIterator[models.Gpxfile]:
        result = await self._conn.stream(sqlalchemy.text(GET_GPX_FILES))
        async for row in result:
            yield models.Gpxfile(
                id=row[0],
                filepath=row[1],
                checksum=row[2],
            )

    async def get_gpx_files_by_id(self, *, id: str) -> AsyncIterator[models.Gpxfile]:
        result = await self._conn.stream(sqlalchemy.text(GET_GPX_FILES_BY_ID), {"p1": id})
        async for row in result:
            yield models.Gpxfile(
                id=row[0],
                filepath=row[1],
                checksum=row[2],
            )

    async def get_gpx_files_by_user_id(self, *, userid: str) -> AsyncIterator[GetGpxFilesByUserIdRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_GPX_FILES_BY_USER_ID), {"p1": userid})
        async for row in result:
            yield GetGpxFilesByUserIdRow(
                id=row[0],
                filepath=row[1],
                checksum=row[2],
                id_2=row[3],
                userid=row[4],
                fileid=row[5],
                trailname=row[6],
                recordedat=row[7],
                duration=row[8],
                distance=row[9],
                ascent=row[10],
                descent=row[11],
                flagreason=row[12],
                traildata=row[13],
            )

    async def insert_gpx_file(self, *, id: str, filepath: str, checksum: str) -> Optional[models.Gpxfile]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_GPX_FILE), {"p1": id, "p2": filepath, "p3": checksum})).first()
        if row is None:
            return None
        return models.Gpxfile(
            id=row[0],
            filepath=row[1],
            checksum=row[2],
        )
